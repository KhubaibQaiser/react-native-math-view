<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Math Input</title>
    <style>
        body {
            margin: 0;
        }
    </style>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
</head>
<body>
    <div id="root"></div>

    <script src="./dist/bundle.js"></script>
    <script>

        window.onload = configure;

        function init() {
            htmlDOMElement = document.firstChild;
            //window.addEventListener("error", function (event) { logger("Error: " + event.error) });
            content = document.body.appendChild(document.createElement("div"));
            content.id = "MathJax_Content";
            let script = document.createElement('script');
            script.type = "math/tex";
            script.innerHTML = 'x';
            content.appendChild(script);
            script = document.createElement('script');
            script.type = "math/asciimath";
            script.innerHTML = 'x';
            content.appendChild(script);
            script = document.createElement('script');
            script.type = "math/mml";
            script.innerHTML = 'x';
            content.appendChild(script);
        }
    function configure() {
    MathJax.Hub.Config({
    //
    //  Load all input jax and preprocessors
    //  Load AMS extensions and the autoload extension for TeX
    //  Create stand-alone SVG elements with font caches by default
    //    (users can override that)
    //
    jax: ["input/TeX", "input/MathML", "input/AsciiMath", "output/SVG", "output/CommonHTML"],
    extensions: ["toMathML.js"],
    TeX: { extensions: window.Array("AMSmath.js", "AMSsymbols.js", "autoload-all.js") },
    SVG: { useFontCache: true, useGlobalCache: false, EqnChunk: 1000000, EqnDelay: 0 },
    CommonHTML: { EqnChunk: 1000000, EqnDelay: 0, undefinedFamily: "monospace" },

    //
    //  This gets run before MathJax queues any actions
    //
    AuthorInit: function () {
    // Add custom paths to configuration
    for (let key in paths) {
    MathJax.Ajax.config.path[key] = paths[key];
    }

    //delete MathJax.Hub.config.styles;               // don't need any styles
    MathJax.Hub.Startup.MenuZoom = function () { };  // don't load menu or zoom code
    MathJax.Extension.MathEvents = {
    Event: {}, Touch: {}, Hover: {}                  // fake structure to avid errors
    };
    MathJax.Ajax.loaded[MathJax.Ajax.fileURL("[MathJax]/extensions/MathEvents.js")] = true;

    //
    //  When creating stylesheets, no need to wait for them
    //  to become active, so just do the callback
    //
    MathJax.Ajax.timer.create = function (callback, node) {
    callback = MathJax.Callback(callback);
    callback(this.STATUS.OK);
    return callback;
    };

    //
    //  Use the console for messages, if we are requesting them
    //
    MathJax.Message.Set = function (text, n, delay) {
    if (displayMessages && n !== 0) {
    if (text instanceof window.Array) { text = MathJax.Localization._.apply(MathJax.Localization, text) }
    logger(text);
    }
    };
    MathJax.Message.Clear = function () { };
    MathJax.Message.Remove = function () { };
    MathJax.Message.Init = function () { };

    //
    //  Trap Math Processing Errors
    //
    MathJax.Hub.Register.MessageHook("Math Processing Error", function (message) {
    AddError("Math Processing Error: " + message[2].message);
    });
    MathJax.Hub.Register.MessageHook("SVG Jax - unknown char", function (message) {
    AddError("SVG - Unknown character: U+" + message[1].toString(16).toUpperCase() +
    " in " + (message[2].fonts || ["unknown"]).join(","), !undefinedChar);
    });
    MathJax.Hub.Register.MessageHook("CommonHTML Jax - unknown char", function (message) {
    AddError("CHTML - Unknown character: U+" + message[1].toString(16).toUpperCase() +
    " in " + (message[2].fonts || ["unknown"]).join(","), !undefinedChar);
    });
    MathJax.Hub.Register.MessageHook("MathML Jax - unknown node type", function (message) {
    AddError("MathML - Unknown node type: " + message[1]);
    });
    MathJax.Hub.Register.MessageHook("MathML Jax - parse error", function (message) {
    AddError("MathML - " + message[1]);
    });
    MathJax.Hub.Register.MessageHook("AsciiMath Jax - parse error", function (message) {
    AddError("AsciiMath parse error: " + message[1]);
    });
    MathJax.Hub.Register.MessageHook("TeX Jax - parse error", function (message) {
    AddError("TeX parse error: " + message[1]);
    });
    MathJax.Hub.Register.MessageHook("file load error", function (message) {
    AddError("File load error: " + message[1]);
    });

    //
    //  Set the delays to 0 (we don't need to update the screen)
    //
    MathJax.Hub.processSectionDelay = 0;
    MathJax.Hub.processUpdateTime = 10000000;  // don't interrupt processing of output
    MathJax.Hub.processUpdateDelay = 0;

    //
    //  Adjust the SVG output jax
    //
    MathJax.Hub.Register.StartupHook("SVG Jax Config", function () {
    var SVG = MathJax.OutputJax.SVG, HTML = MathJax.HTML;

    //
    //  Don't need the styles
    //
    delete SVG.config.styles

    SVG.Augment({
    //
    //  Set up the default ex-size and width
    //
    InitializeSVG: function () {
    this.pxPerInch = 96;
    this.defaultEx = 6;
    this.defaultWidth = 100;
    },
    //
    //  Adjust preTranslate() to not try to find the ex-size or
    //  the container widths.
    //
    preTranslate: function (state) {
    var scripts = state.jax[this.id], i, m = scripts.length,
    script, prev, span, div, jax, ex, em,
    maxwidth = 100000, relwidth = false, cwidth,
    linebreak = this.config.linebreaks.automatic,
    width = this.config.linebreaks.width;
    //
    //  Loop through the scripts
    //
    for (i = 0; i < m; i++) {
    script = scripts[i]; if (!script.parentNode) continue;
    //
    //  Remove any existing output
    //
    prev = script.previousSibling;
    if (prev && String(prev.className).match(/^MathJax(_SVG)?(_Display)?( MathJax(_SVG)?_Processing)?$/)) { prev.parentNode.removeChild(prev) }
    //
    //  Add the span, and a div if in display mode,
    //  then mark it as being processed
    //
    jax = script.MathJax.elementJax; if (!jax) continue;
    jax.SVG = { display: (jax.root.Get("display") === "block") }
    span = div = HTML.Element("span", {
    style: { "font-size": this.config.scale + "%", display: "inline-block" },
    className: "MathJax_SVG", id: jax.inputID + "-Frame", isMathJax: true, jaxID: this.id
    });
    if (jax.SVG.display) {
    div = HTML.Element("div", { className: "MathJax_SVG_Display" });
    div.appendChild(span);
    }
    div.className += " MathJax_SVG_Processing";
    script.parentNode.insertBefore(div, script);
    //
    //  Set SVG data for jax
    //
    jax.SVG.ex = ex = (data || defaults).ex;
    jax.SVG.em = em = ex / SVG.TeX.x_height * 1000; // scale ex to x_height
    jax.SVG.cwidth = width / em * 1000;
    jax.SVG.lineWidth = (linebreak ? width / em * 1000 : SVG.BIGDIMEN);
    }
    //
    //  Set state variables used for displaying equations in chunks
    //
    state.SVGeqn = state.SVGlast = 0; state.SVGi = -1;
    state.SVGchunk = this.config.EqnChunk;
    state.SVGdelay = false;
    }
    });

    //
    //  TEXT boxes use getBBox, which isn't implemented, so
    //  use a monspace font and fake the size.  Since these
    //  are used only for error messages and undefined characters,
    //  this should be good enough for now.
    //
    SVG.BBOX.TEXT.Augment({
    Init: function (scale, text, def) {
    if (!def) { def = {} }; def.stroke = "none";
    if (def["font-style"] === "") delete def["font-style"];
    if (def["font-weight"] === "") delete def["font-weight"];
    this.SUPER(arguments).Init.call(this, def);
    SVG.addText(this.element, text);
    // tweaking font fallback behavior: https://github.com/mathjax/MathJax-node/issues/299
    var textWidth = text.split('')
    .map(function (c) { return isFullwidthCodePoint(c.codePointAt()) ? data.cjkCharWidth : 8.5 })
    .reduce(function (a, b) { return a + b }, 0);
    var bbox = { width: textWidth, height: 18, y: -12 };
    scale *= 1000 / SVG.em;
    this.element.setAttribute("font-family", "monospace");
    this.element.setAttribute("transform", "scale(" + scale + ") matrix(1 0 0 -1 0 0)");
    this.w = this.r = bbox.width * scale; this.l = 0;
    this.h = this.H = -bbox.y * scale;
    this.d = this.D = (bbox.height + bbox.y) * scale;
    }
    });

    //
    //  Don't have mglyph load images
    //
    MathJax.Hub.Register.StartupHook("SVG mglyph Ready", function () {
    var MML = MathJax.ElementJax.mml;
    var MGLYPH = MML.mglyph;
    var TOSVG = MGLYPH.prototype.toSVG;
    MGLYPH.Augment({
    toSVG: function (variant, scale) {
    var values = this.getValues("src", "width", "height");
    if (values.src !== "" && !MGLYPH.GLYPH[values.src]) {
    if (!values.width || !values.height) {
    AddError("mglyphs must have explicit width and height in mathjax-node");
    }
    MGLYPH.GLYPH[values.src] = {
    img: { SRC: values.src, width: 0, height: 0 },
    status: "OK"
    };
    }
    return TOSVG.apply(this, arguments);
    }
    });
    });

    });

    //
    //  Adjust the CommonHTML output jax
    //
    MathJax.Hub.Register.StartupHook("CommonHTML Jax Config", function () {
    var CHTML = MathJax.OutputJax.CommonHTML, HTML = MathJax.HTML;

    //
    //  Don't need these styles
    //
    var STYLES = CHTML.config.styles;
    delete STYLES["#MathJax_CHTML_Tooltip"];
    delete STYLES[".MJXc-processing"];
    delete STYLES[".MJXc-processed"];
    delete STYLES[".mjx-chartest"];
    delete STYLES[".mjx-chartest .mjx-char"];
    delete STYLES[".mjx-chartest .mjx-box"];
    delete STYLES[".mjx-test"];
    delete STYLES[".mjx-ex-boxtest"];
    //  fontURL to current MathJax version
    if (!fontURL) {
    fontURL = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/' + MathJax.version + '/fonts/HTML-CSS';
    }
    CHTML.Augment({
    webfontDir: fontURL,
    //
    //  Set up the default ex-size and width
    //
    getDefaultExEm: function () {
    var styles = document.head.getElementsByTagName("style");
    CHTMLSTYLES = styles[styles.length - 1].innerHTML;
    this.pxPerInch = 96;
    this.defaultEx = 6;
    this.defaultEm = 6 / CHTML.TEX.x_height * 1000;
    this.defaultWidth = 100;
    },
    //
    //  Adjust preTranslate() to not try to find the ex-size or
    //  the container widths.
    //
    preTranslate: function (state) {
    var scripts = state.jax[this.id], i, m = scripts.length,
    script, prev, node, jax, ex, em,
    maxwidth = 100000, relwidth = false, cwidth = 0,
    linebreak = this.config.linebreaks.automatic,
    width = this.config.linebreaks.width;
    //
    //  Loop through the scripts
    //
    for (i = 0; i < m; i++) {
    script = scripts[i]; if (!script.parentNode) continue;
    //
    //  Remove any existing output
    //
    prev = script.previousSibling;
    if (prev && prev.className && String(prev.className).substr(0, 9) === "mjx-chtml")
    prev.parentNode.removeChild(prev);
    //
    //  Add the node for the math and mark it as being processed
    //
    jax = script.MathJax.elementJax; if (!jax) continue;
    jax.CHTML = { display: (jax.root.Get("display") === "block") }
    node = CHTML.Element("mjx-chtml", {
    id: jax.inputID + "-Frame", isMathJax: true, jaxID: this.id
    });
    if (jax.CHTML.display) {
    //
    // Zoom box requires an outer container to get the positioning right.
    //
    var NODE = CHTML.Element("mjx-chtml", { className: "MJXc-display", isMathJax: false });
    NODE.appendChild(node); node = NODE;
    }

    node.className += " MJXc-processing";
    script.parentNode.insertBefore(node, script);
    //
    //  Set CHTML data for jax
    //
    jax.CHTML.ex = ex = (data || defaults).ex;
    jax.CHTML.em = jax.CHTML.outerEm = em = ex / CHTML.TEX.x_height; // scale ex to x_height
    jax.CHTML.cwidth = width / em;
    jax.CHTML.lineWidth = (linebreak ? width / em : 1000000);
    jax.CHTML.scale = 1; jax.CHTML.fontsize = "100%";
    }
    //
    //  Set state variables used for displaying equations in chunks
    //
    state.CHTMLeqn = state.CHTMLlast = 0; state.CHTMLi = -1;
    state.CHTMLchunk = this.config.EqnChunk;
    state.CHTMLdelay = false;
    },

    //
    //  We are using a monospaced font, so fake the size
    //
    getHDW: function (c, name, styles) {
    return { h: .8, d: .2, w: c.length * .5 };
    }

    });

    //
    //  Don't have mglyph load images
    //
    MathJax.Hub.Register.StartupHook("CommonHTML mglyph Ready", function () {
    var MML = MathJax.ElementJax.mml;
    var MGLYPH = MML.mglyph;
    var TOCHTML = MGLYPH.prototype.toCommonHTML;
    MGLYPH.Augment({
    toCommonHTML: function (node, options) {
    var values = this.getValues("src", "width", "height");
    if (values.src !== "" && !MGLYPH.GLYPH[values.src]) {
    if (!values.width || !values.height) {
    AddError("mglyphs must have explicit width and height in mathjax-node");
    }
    MGLYPH.GLYPH[values.src] = {
    img: { SRC: values.src, width: 0, height: 0 },
    status: "OK"
    };
    }
    return TOCHTML.apply(this, arguments);
    }
    });
    });

    });

    //
    //  Set up None output jax (for when only MathML output is needed)
    //
    MathJax.Hub.Register.StartupHook("End Jax", function () {
    MathJax.OutputJax.None = MathJax.OutputJax({
    id: "None",
    preTranslate: function () { },
    Translate: function () { },
    postTranslate: function () { }
    });
    MathJax.OutputJax.None.loadComplete("jax.js");
    MathJax.OutputJax.None.Register("jax/mml");
    });

    //
    //  Reset the color extension after `autoload-all`
    //
    if (MathJax.AuthorConfig.extensions.indexOf("TeX/color.js") == -1 && MathJax.AuthorConfig.extensions.indexOf("TeX/autoload-all.js") == -1) {
    MathJax.Hub.Register.StartupHook("TeX autoload-all Ready", function () {
    var macros = MathJax.InputJax.TeX.Definitions.macros;
    macros.color = "Color";
    delete macros.textcolor;
    delete macros.colorbox;
    delete macros.fcolorbox;
    delete macros.definecolor;
    });
    }

    //
    //  Start the typesetting queue when MathJax is ready
    //    (reseting the counters so that the initial math doesn't affect them)
    //
    MathJax.Hub.Register.StartupHook("End", function () {
    if (MathJax.OutputJax.SVG.resetGlyphs) MathJax.OutputJax.SVG.resetGlyphs(true);
    MathJax.ElementJax.mml.ID = 0;
    if (serverState === STATE.RESTART) {
    setTimeout(RestartMathJax, 100);
    } else {
    serverState = STATE.READY;
    MathJax.Hub.Queue(
    function () { sErrors = errors },
    StartQueue
    );
    }
    });
    }
    });
    MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }

    </script>
</body>
</html>
